import { bytesToHex, Yespower, hexToBytes } from 'yespower-wasm';
import { webcrypto } from 'crypto';
import { Worker as Worker$1 } from 'worker_threads';
import WebSocket from 'isomorphic-ws';
import { EventEmitter } from 'eventemitter3';

const isNode = !(process?.browser && window);
const ZeroHash = "0x0000000000000000000000000000000000000000000000000000000000000000";
function toDiff(target) {
  return 2n ** 256n / BigInt(target);
}
function concatBytes(...arrays) {
  if (arrays.length === 1) return arrays[0];
  const length = arrays.reduce((a, arr) => a + arr.length, 0);
  const result = new Uint8Array(length);
  for (let i = 0, pad = 0; i < arrays.length; i++) {
    const arr = arrays[i];
    result.set(arr, pad);
    pad += arr.length;
  }
  return result;
}
function setLength(msg, length, right = false) {
  if (right) {
    if (msg.length < length) {
      return new Uint8Array([...msg, ...new Uint8Array(length - msg.length)]);
    }
    return msg.subarray(0, length);
  } else {
    if (msg.length < length) {
      return new Uint8Array([...new Uint8Array(length - msg.length), ...msg]);
    }
    return msg.subarray(-length);
  }
}
function randomNonce() {
  return BigInt(bytesToHex(webcrypto.getRandomValues(new Uint8Array(63))));
}
function bytesReverse(a) {
  const length = a.length;
  const b = new Uint8Array(length);
  for (let i = 0; i < length; i++) {
    b[i] = a[length - i - 1];
  }
  return b;
}

async function findNonce(work, reportOn = 100, workerId, algoPers, isWorker, msgSend) {
  const yespower = await Yespower.init();
  let timeStart = Date.now();
  let nonce = randomNonce();
  let i = 0;
  const blockTarget = work.blockTarget?.startsWith("0x") ? BigInt(work.blockTarget) : 0n;
  const target = BigInt(work.target);
  const header = hexToBytes(work.header);
  while (true) {
    const nonceBytes = setLength(hexToBytes(nonce.toString(16)), 8, false);
    const concatted = concatBytes(header, bytesReverse(nonceBytes));
    const result = BigInt(bytesToHex(yespower.Hash(concatted, void 0, void 0, algoPers)));
    const blockFound = blockTarget > result;
    if (target > result) {
      const found = {
        nonce: bytesToHex(nonceBytes),
        header: work.header,
        blockNumber: work.blockNumber,
        blockFound
      };
      if (msgSend) {
        msgSend({
          type: "nonce",
          workerId,
          ...found
        });
      }
      if (!isWorker) {
        return found;
      }
    }
    if (i && i % reportOn === 0) {
      const timeTook = Date.now() - timeStart;
      const hashrate = Math.floor(1e3 * reportOn / timeTook);
      if (msgSend) {
        msgSend({
          type: "hashrate",
          workerId,
          hashrate
        });
      }
      timeStart = Date.now();
    }
    i++;
    nonce++;
  }
}

async function mine(miner, work) {
  for (let i = 0; i < miner.threads; ++i) {
    if (isNode) {
      const worker = new Worker$1(miner.workerFile, {
        workerData: {
          ...work,
          workerId: i
        }
      });
      worker.on("message", async (msg) => {
        if (msg.type === "nonce") {
          const { nonce, header } = msg;
          miner.pool.submitWork(nonce, header);
        } else if (msg.type === "hashrate") {
          const { workerId, hashrate } = msg;
          miner.hashrates[workerId] = hashrate;
        }
        if (miner.onMessage) {
          const allHashrate = msg.type === "hashrate" ? Object.values(miner.hashrates).reduce((acc, curr) => acc + curr, 0) : void 0;
          miner.onMessage({
            ...msg,
            allHashrate
          });
        }
      });
      worker.on("error", (e) => {
        console.log(`Error from ${i} worker, exiting`);
        console.log(e);
        worker.terminate();
      });
      await new Promise((resolve) => {
        worker.on("online", () => {
          resolve(true);
        });
      });
      miner.workers.push(worker);
    } else {
      const worker = new Worker(miner.workerFile);
      worker.onmessage = (e) => {
        const msg = e.data;
        if (msg.type === "nonce") {
          const { nonce, header } = msg;
          miner.pool.submitWork(nonce, header);
        } else if (msg.type === "hashrate") {
          const { workerId, hashrate } = msg;
          miner.hashrates[workerId] = hashrate;
        }
        if (miner.onMessage) {
          const allHashrate = msg.type === "hashrate" ? Object.values(miner.hashrates).reduce((acc, curr) => acc + curr, 0) : void 0;
          miner.onMessage({
            ...msg,
            allHashrate
          });
        }
      };
      worker.onerror = (e) => {
        console.log(`Error from ${i} worker, exiting`);
        console.log(e);
        worker.terminate();
      };
      worker.postMessage(work);
    }
  }
}
async function stop(miner) {
  await Promise.all(
    miner.workers.map((worker) => {
      return new Promise((resolve) => {
        if (isNode) {
          worker.on("exit", () => {
            resolve(true);
          });
          worker.terminate();
        } else {
          worker.terminate();
          resolve(true);
        }
      });
    })
  );
  miner.workers.length = 0;
}
class Miner {
  workerFile;
  threads;
  pool;
  algoPers;
  onMessage;
  workers;
  hashrates;
  prevWork;
  constructor({ workerFile, threads, pool, algoPers, onMessage }) {
    this.workerFile = workerFile;
    this.threads = threads;
    this.pool = pool;
    this.algoPers = algoPers;
    this.onMessage = onMessage;
    this.workers = [];
    this.hashrates = {};
    this.prevWork = "";
  }
  stop() {
    return stop(this);
  }
  async start() {
    this.pool.on("work", (work2) => {
      this.mine(work2);
    });
    const work = await this.pool.getWork();
    return this.mine(work);
  }
  async mine(work) {
    const newWork = JSON.stringify(work);
    if (this.prevWork === newWork) {
      return;
    }
    if (this.onMessage) {
      this.onMessage({
        type: "newWork",
        ...work
      });
    }
    await this.stop();
    await mine(this, {
      ...work,
      algoPers: this.algoPers
    });
    this.prevWork = newWork;
  }
}

function sendWS(pool, method, params, worker, lastHead) {
  const id = Number(pool.id);
  return new Promise((resolve, reject) => {
    const msg = JSON.stringify({
      id,
      jsonrpc: "2.0",
      method,
      params,
      worker
    });
    const queue = {
      id,
      resolve,
      reject,
      isResolved: false,
      lastHead
    };
    queue.timeout = setTimeout(() => {
      if (!queue.isResolved) {
        queue.reject(new Error("Request timeout"));
        queue.isResolved = true;
      }
    }, 2e4);
    pool.queue.push(queue);
    pool.ws.send(msg, (err) => {
      if (err) {
        reject(err);
      }
    });
    pool.id++;
  });
}
function listenWS(pool) {
  return new Promise((resolve, reject) => {
    pool.ws.onclose = () => {
      pool.log(`Websocket closed, reconnecting on ${pool.reconnect} ms`, "error");
      setTimeout(() => {
        pool.ws = new WebSocket(pool.url);
        listenWS(pool);
      }, pool.reconnect);
    };
    pool.ws.onerror = () => {
      pool.log("Websocket encountered error, reconnecting it", "error");
      pool.ws.close();
    };
    pool.ws.onopen = () => {
      pool.submitLogin().then((r) => {
        if (!r) {
          reject(new Error("Pool returned invalid connection boolean"));
        } else {
          if (pool.login) {
            pool.log(`Connected to pool ${pool.url}: ${pool.login}/${pool.worker}`);
          } else {
            pool.log(`Connected to node ${pool.url}`);
          }
          resolve(r);
        }
      }).catch((e) => reject(e));
    };
    pool.ws.onmessage = (d) => {
      try {
        const data = d?.data ? JSON.parse(d.data) : null;
        if (!data) {
          throw new Error("Invalid data");
        }
        if (data.method === "eth_subscription") {
          pool.getWork().then((w) => pool.emit("work", w));
          return;
        }
        if (data.id === 0 && data.result?.length > 2) {
          pool.emit("work", {
            header: data.result[0],
            blockTarget: data.result[1],
            target: data.result[2],
            blockNumber: data.result[3]
          });
          return;
        }
        const msg = pool.queue.find((q) => q.id === data.id);
        if (!msg) {
          return;
        }
        if (msg.lastHead && msg.lastHead !== data.result.hash) {
          pool.getWork().then((w) => pool.emit("work", w));
        }
        if (data.error) {
          msg.reject(data.error);
        } else {
          msg.resolve(data.result);
        }
        msg.isResolved = true;
        pool.queue = pool.queue.filter((q) => !q.isResolved);
      } catch (err) {
        pool.log(
          `Caught error while handing incoming message from pool ${pool.url}, reconnecting: ${err.stack || err.message}`,
          "error"
        );
        console.log(err);
        pool.ws.close();
      }
    };
  });
}
class WebSocketPool extends EventEmitter {
  url;
  login;
  worker;
  reconnect;
  onMessage;
  ws;
  connected;
  id;
  queue;
  constructor({ url, login, worker, reconnect, onMessage }) {
    super();
    this.url = url;
    this.login = login;
    this.worker = worker;
    this.reconnect = reconnect || 500;
    this.onMessage = onMessage;
    this.ws = new WebSocket(url);
    this.id = 1;
    this.queue = [];
    this.connected = listenWS(this);
  }
  log(msg, level) {
    if (this.onMessage) {
      this.onMessage({
        type: "websocket",
        level,
        msg
      });
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  send(method, params, worker, lastHead) {
    return sendWS(this, method, params, worker, lastHead);
  }
  async submitLogin() {
    if (!this.login) {
      const blockNum = await this.send("eth_subscribe", ["newHeads"]);
      if (blockNum?.startsWith("0x")) {
        return true;
      } else {
        return false;
      }
    }
    return this.send("eth_submitLogin", [this.login], this.worker);
  }
  async getWork() {
    await this.connected;
    const result = await this.send("eth_getWork");
    return {
      header: result[0],
      blockTarget: result[1],
      target: result[2],
      blockNumber: result[3]
    };
  }
  async submitWork(nonce, header) {
    await this.connected;
    const valid = await this.send("eth_submitWork", [nonce, header, ZeroHash], this.worker);
    if (!this.login) {
      await this.send("eth_getBlockByNumber", ["latest", false], void 0, header);
    }
    return valid;
  }
}

export { Miner, WebSocketPool, ZeroHash, bytesReverse, concatBytes, findNonce, isNode, listenWS, mine, randomNonce, sendWS, setLength, stop, toDiff };
